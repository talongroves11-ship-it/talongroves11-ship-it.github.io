<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
<title>3D Drift — Playable in Safari</title>
<style>
  html,body { height:100%; margin:0; background:#0b0b0f; overflow:hidden; -webkit-tap-highlight-color: transparent; }
  #ui {
    position:fixed; left:12px; top:12px; z-index:10; color:#fff; font-family:Inter,Arial,sans-serif;
    text-shadow:0 2px 8px rgba(0,0,0,0.7);
  }
  #ui .stat { margin-bottom:6px; font-size:16px; }
  #controls {
    position:fixed; right:12px; bottom:12px; z-index:12; display:flex; gap:10px; align-items:center;
    pointer-events:none;
  }
  .pad { pointer-events:auto; width:74px; height:74px; border-radius:50%; background:#ffffff22; border:2px solid #ffffff33;
        display:flex; align-items:center; justify-content:center; color:#fff; font-weight:bold; font-size:18px; user-select:none; touch-action:none; }
  #leftPad { transform:translateX(-10px); }
  #rightPad { transform:translateX(10px); }
  #upPad { width:58px; height:58px; border-radius:12px; font-size:14px; display:flex; align-items:center; justify-content:center; }
  #footerNote { position:fixed; left:12px; bottom:10px; color:#aaa; font-size:12px; z-index:9; }
  canvas { display:block; }
</style>
</head>
<body>
<div id="ui">
  <div class="stat" id="speed">Speed: 0 km/h</div>
  <div class="stat" id="drift">Drift: 0</div>
  <div class="stat" id="score">Score: 0</div>
</div>

<div id="controls">
  <div id="leftPad" class="pad">◀</div>
  <div id="upPad" class="pad" style="width:86px;height:86px;border-radius:14px;font-size:15px;">▲</div>
  <div id="rightPad" class="pad">▶</div>
</div>

<div id="footerNote">Tap controls on phone — arrow keys work on desktop</div>

<!-- three.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>

<script>
/* =========================
   3D Drift Game - Single File
   Simplified arcade drifting physics + visuals
   ========================= */

// === BASIC SETUP ===
let scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0b0b0f, 0.0009);

let camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 2000);
camera.position.set(0, 6, -12);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

// resize
window.addEventListener('resize', ()=> {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// === LIGHTING ===
const hemi = new THREE.HemisphereLight(0xbfeaff, 0x080820, 0.9);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(-10, 20, 10);
dir.castShadow = true;
dir.shadow.mapSize.set(1024,1024);
dir.shadow.camera.left = -40; dir.shadow.camera.right = 40; dir.shadow.camera.top = 40; dir.shadow.camera.bottom = -40;
scene.add(dir);

// subtle rim light
const rim = new THREE.DirectionalLight(0x88c0ff, 0.2);
rim.position.set(10, 10, -10);
scene.add(rim);

// === GROUND / TRACK ===
const groundGeo = new THREE.PlaneGeometry(1200, 1200, 10, 10);
const groundMat = new THREE.MeshStandardMaterial({ color:0x1e242a, roughness:0.8, metalness:0.1 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// add a subtle track texture lines (procedural)
const lineGeo = new THREE.PlaneGeometry(1200, 1200, 1, 1);
const lineMat = new THREE.MeshBasicMaterial({ color:0x20262b, transparent:true, opacity:0.35 });
const lines = new THREE.Mesh(lineGeo, lineMat);
lines.rotation.x = -Math.PI/2;
lines.position.y = 0.01;
scene.add(lines);

// === ENV: low poly skyline boxes for depth ===
const boxGeom = new THREE.BoxGeometry(1,1,1);
for(let i=0;i<160;i++){
  let b = new THREE.Mesh(boxGeom, new THREE.MeshStandardMaterial({ color: 0x0f1418, roughness:0.9 }));
  b.scale.setScalar(1 + Math.random()*10);
  b.position.set((Math.random()-0.5)*600, b.scale.y*0.5, (Math.random()-0.5)*600);
  b.material.emissive = new THREE.Color(0x000000);
  scene.add(b);
}

// === CAR (group made from simple boxes) ===
const car = new THREE.Group();
car.position.set(0, 0.6, 0);
scene.add(car);

const bodyGeo = new THREE.BoxGeometry(1.8, 0.5, 3.6);
const bodyMat = new THREE.MeshStandardMaterial({ color:0xff2d2d, metalness:0.4, roughness:0.3 });
const body = new THREE.Mesh(bodyGeo, bodyMat);
body.castShadow = true;
body.position.y = 0.4;
car.add(body);

// roof
const roofGeo = new THREE.BoxGeometry(1.2,0.22,1.4);
const roof = new THREE.Mesh(roofGeo, new THREE.MeshStandardMaterial({ color:0x111827, roughness:0.2 }));
roof.position.set(0,0.7,-0.15);
roof.castShadow = true;
car.add(roof);

// wheels (visual)
const wheelGeom = new THREE.CylinderGeometry(0.33,0.33,0.3,12);
const wheelMat = new THREE.MeshStandardMaterial({ color:0x0b0b0b, metalness:0.6, roughness:0.5 });
function makeWheel(x,z){
  let w = new THREE.Mesh(wheelGeom, wheelMat);
  w.rotation.z = Math.PI/2;
  w.position.set(x, 0.2, z);
  w.castShadow = true;
  car.add(w);
  return w;
}
const wfl = makeWheel(-0.9, 1.0);
const wfr = makeWheel(0.9, 1.0);
const wrl = makeWheel(-0.9, -1.2);
const wrr = makeWheel(0.9, -1.2);

// small spoiler
const spoiler = new THREE.Mesh(new THREE.BoxGeometry(1.4,0.05,0.2), new THREE.MeshStandardMaterial({ color:0xff2d2d }));
spoiler.position.set(0,0.6,-1.8);
car.add(spoiler);

// === PARTICLES (smoke) ===
const particleCount = 120;
const particlesGeo = new THREE.BufferGeometry();
const positions = new Float32Array(particleCount * 3);
const sizes = new Float32Array(particleCount);
for (let i=0;i<particleCount;i++){ positions[i*3]=0; positions[i*3+1]= -10; positions[i*3+2]=0; sizes[i]=1.0; }
particlesGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
particlesGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
const sprite = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAIElEQVQoz2NgwAGMDEwMDAw8P///w8GBgYGBoYmBgAAAN8IBnA5Y7wAAAAASUVORK5CYII=');
const particlesMat = new THREE.PointsMaterial({ size:0.5, map:sprite, transparent:true, opacity:0.55, depthWrite:false, color:0xaaaaaa });
const particles = new THREE.Points(particlesGeo, particlesMat);
particles.frustumCulled = false;
scene.add(particles);

// === GAME STATE & PHYSICS ===
let vel = new THREE.Vector3(0,0,0); // world-space velocity
let forward = new THREE.Vector3(0,0,1);
let yaw = 0;
let throttle = 0;
let steerInput = 0;
let handbrake = false;

const params = {
  maxSpeed: 40,       // m/s
  accel: 30,          // m/s^2
  brake: 50,
  steerSpeed: 2.8,    // how fast car turns (radians/s) at low speed
  driftFactor: 0.9,   // lower = more drift (0.7 aggressive)
  grip: 0.92,         // overall grip
  downforce: 6,
  smokeThreshold: 5.5,
  score: 0
};

// helper to get local velocity (car space)
function getLocalVelocity() {
  // transform velocity into car local (z forward)
  let inv = new THREE.Matrix4().extractRotation(car.matrixWorld).invert();
  let local = vel.clone().applyMatrix4(inv);
  return local;
}

// control state
const keys = { left:false, right:false, up:false, down:false, space:false };

// input handlers (keyboard)
window.addEventListener('keydown', e => {
  if(e.key==='ArrowLeft') keys.left=true;
  if(e.key==='ArrowRight') keys.right=true;
  if(e.key==='ArrowUp') keys.up=true;
  if(e.key==='ArrowDown') keys.down=true;
  if(e.key===' ') keys.space=true;
});
window.addEventListener('keyup', e => {
  if(e.key==='ArrowLeft') keys.left=false;
  if(e.key==='ArrowRight') keys.right=false;
  if(e.key==='ArrowUp') keys.up=false;
  if(e.key==='ArrowDown') keys.down=false;
  if(e.key===' ') keys.space=false;
});

// touch controls
const leftPad = document.getElementById('leftPad');
const rightPad = document.getElementById('rightPad');
const upPad = document.getElementById('upPad');

function addTouch(el, downCb, upCb) {
  el.addEventListener('touchstart', e => { e.preventDefault(); downCb(); }, {passive:false});
  el.addEventListener('touchend', e => { e.preventDefault(); upCb(); }, {passive:false});
}
addTouch(leftPad, ()=> keys.left=true, ()=> keys.left=false);
addTouch(rightPad, ()=> keys.right=true, ()=> keys.right=false);
addTouch(upPad, ()=> keys.up=true, ()=> keys.up=false);

// === CAMERA SMOOTH FOLLOW ===
const camTarget = new THREE.Object3D();
scene.add(camTarget);
const camOffset = new THREE.Vector3(0, 3.2, -8.0);
let camVel = new THREE.Vector3();

// UI elements
const speedEl = document.getElementById('speed');
const driftEl = document.getElementById('drift');
const scoreEl = document.getElementById('score');

// Utility
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// === MAIN UPDATE LOOP ===
let last = performance.now();
function animate(t){
  const dt = Math.min(0.033, (t - last) / 1000);
  last = t;

  // read inputs
  throttle = keys.up ? 1 : (keys.down ? -0.5 : 0);
  steerInput = (keys.left? -1:0) + (keys.right? 1:0);
  handbrake = keys.space;

  // forward vector (car local forward in world)
  const carForward = new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);

  // accelerate/brake along forward direction
  const accelVec = carForward.clone().multiplyScalar(throttle * params.accel * dt);
  vel.add(accelVec);

  // natural drag
  vel.multiplyScalar(0.995);

  // turning: steering effectiveness reduces with speed (so easier at low speed)
  const speed = vel.length();
  const speedFactor = clamp(speed / 10, 0.05, 1.0);
  // yaw change from steering + drifting (simulate counter-steer)
  const yawRate = steerInput * params.steerSpeed * (1 + (0.6 - speedFactor));
  yaw += yawRate * dt * (speed / (1+speed));

  // apply yaw rotation to orientation slowly influenced by velocity
  // orientation aims to align with velocity direction slowly (simulating under/oversteer)
  // compute slip factor based on lateral velocity
  const local = getLocalVelocity();
  const lateral = local.x;
  const longitudinal = local.z;
  const slipAngle = Math.atan2(lateral, Math.max(0.0001, Math.abs(longitudinal))) * (180/Math.PI);
  const isDrifting = Math.abs(lateral) > params.smokeThreshold && Math.abs(slipAngle) > 6;

  // drift/grip effect: reduce lateral damping to allow drift
  const lateralDamping = handbrake ? 0.65 : (isDrifting ? params.driftFactor : params.grip);
  // apply lateral damping (remove sideways velocity gradually)
  const sideways = car.localToWorld(new THREE.Vector3(1,0,0)).sub(car.position).normalize(); // direction right
  // instead of physics, we blend orientation towards movement and reduce lateral velocity
  // compute desired forward direction from yaw and small alignment from velocity
  const qYaw = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, yaw, 0));
  // rotate velocity to reduce lateral component
  const localVel = getLocalVelocity();
  localVel.x *= lateralDamping;
  // reconstruct world vel from local
  const worldVel = new THREE.Vector3(localVel.x, localVel.y, localVel.z).applyQuaternion(car.quaternion);
  vel.copy(worldVel);

  // apply subtle downforce to help stability
  vel.add(carForward.clone().multiplyScalar(-params.downforce * 0.0005 * speed * dt));

  // limit speed
  if (vel.length() > params.maxSpeed) vel.setLength(params.maxSpeed);

  // update car position from vel
  car.position.addScaledVector(vel, dt);

  // rotate car to face a blend of yaw and velocity direction
  const velDir = vel.clone().normalize();
  if (vel.length() > 0.5) {
    const forwardDir = carForward.clone().normalize();
    // target orientation: mix yaw-based orientation and velocity direction
    const yawQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, yaw, 0));
    const targetDir = vel.clone().normalize();
    const targetQ = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), targetDir);
    // blend factor depending on speed and drifting
    const blend = clamp(0.02 + (isDrifting ? 0.2 : 0.06) + (speed / 80), 0.02, 0.6);
    car.quaternion.slerp(targetQ.slerp(yawQ, 0.5), blend);
  } else {
    car.quaternion.slerp(new THREE.Quaternion().setFromEuler(new THREE.Euler(0,yaw,0)), 0.08);
  }

  // spin wheels (visual)
  const wheelSpin = vel.length() * 6;
  [wfl, wfr, wrl, wrr].forEach((w, idx)=> {
    w.rotation.x += wheelSpin * dt;
  });

  // particles: spawn behind rear wheels when drifting
  updateParticles(isDrifting, dt);

  // camera follow (smooth)
  const camPos = car.position.clone().add(new THREE.Vector3(0, 2.6, -8).applyQuaternion(car.quaternion));
  camera.position.lerp(camPos, 0.12);
  const lookAt = car.position.clone().add(new THREE.Vector3(0,1,0));
  camera.lookAt(lookAt);

  // small FOV kick based on speed
  camera.fov = 55 + clamp(vel.length()/params.maxSpeed * 8, 0, 10);
  camera.updateProjectionMatrix();

  // update UI
  speedEl.innerText = "Speed: " + Math.round(vel.length()*3.6) + " km/h";
  driftEl.innerText = "Drift: " + Math.round(Math.abs(local.x)*10);
  if (isDrifting) params.score += Math.abs(local.x) * dt * 6;
  scoreEl.innerText = "Score: " + Math.floor(params.score);

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

function updateParticles(spawning, dt){
  const pos = particles.geometry.attributes.position.array;
  for (let i=0;i<particleCount;i++){
    const idx = i*3;
    // if off-screen place below ground
    if (pos[idx+1] < -5) {
      pos[idx] = car.position.x + (Math.random()-0.5)*0.4;
      pos[idx+1] = car.position.y - 0.1;
      pos[idx+2] = car.position.z + (Math.random()-0.5)*0.4 -1.2;
    } else {
      // rise and fade away
      pos[idx] += (Math.random()-0.5) * 0.04;
      pos[idx+1] += 0.02 + Math.random()*0.05;
      pos[idx+2] += (Math.random()-0.5) * 0.04;
      // slowly sink if not spawning
      if (!spawning) pos[idx+1] -= 0.02;
    }
  }
  if (spawning) {
    // nudge a block of particles near rear
    for (let j=0;j<10;j++){
      let i = Math.floor(Math.random()*particleCount);
      let idx = i*3;
      pos[idx] = car.position.x + (Math.random()-0.5)*0.5;
      pos[idx+1] = car.position.y - 0.05;
      pos[idx+2] = car.position.z - 1.3 + (Math.random()*0.3);
    }
  }
  particles.geometry.attributes.position.needsUpdate = true;
}

// initial populate particles under ground so they come in on spawn
for (let i=0;i<particleCount;i++){
  positions[i*3+1] = -10;
}
particles.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

// start loop
requestAnimationFrame(animate);

// ========== HELPER: simple instruction overlay for desktop ==========
const allowRotate = false;
if (allowRotate){
  // optional controls, left out for clarity to focus on drift
}

// === done ===

</script>
</body>
</html>

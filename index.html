<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
<title>3D Drift — Upgraded</title>
<style>
  html,body{height:100%;margin:0;background:#06060a;overflow:hidden;-webkit-tap-highlight-color:transparent}
  #ui{position:fixed;left:12px;top:12px;z-index:20;color:#fff;font-family:Inter,Arial,sans-serif;text-shadow:0 2px 10px rgba(0,0,0,0.7)}
  #ui .stat{margin-bottom:6px;font-size:15px}
  #controls{position:fixed;right:12px;bottom:12px;z-index:21;display:flex;gap:10px;align-items:center;pointer-events:none}
  .pad{pointer-events:auto;width:70px;height:70px;border-radius:50%;background:#ffffff22;border:2px solid #ffffff33;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:bold;font-size:20px;user-select:none;touch-action:none}
  #upPad{width:86px;height:86px;border-radius:14px;font-size:16px}
  #settings{position:fixed;right:12px;top:12px;z-index:22;color:#ddd;font-family:Arial,Helvetica,sans-serif}
  #settings button{display:block;margin-bottom:6px;padding:8px;border-radius:8px;border:0;background:#111;color:#fff;cursor:pointer}
  #footerNote{position:fixed;left:12px;bottom:10px;color:#aaa;font-size:12px;z-index:19}
  canvas{display:block}
  .hud{position:fixed;left:50%;transform:translateX(-50%);top:10px;color:#fff;z-index:22;pointer-events:none}
  .hud .title{font-size:20px;font-weight:700;margin-bottom:6px}
</style>
</head>
<body>
<div id="ui">
  <div class="stat" id="speed">Speed: 0 km/h</div>
  <div class="stat" id="drift">Drift: 0</div>
  <div class="stat" id="score">Score: 0</div>
</div>

<div id="settings">
  <button id="qualityBtn">Quality: High</button>
  <button id="soundBtn">Sound: On</button>
  <button id="restartBtn">Reset Position</button>
</div>

<div class="hud"><div class="title">3D Drift — Upgraded</div></div>

<div id="controls">
  <div id="leftPad" class="pad">◀</div>
  <div id="upPad" class="pad">▲</div>
  <div id="rightPad" class="pad">▶</div>
</div>

<div id="footerNote">Arrow keys or tap controls. Handbrake = space. Try bumping AI cars.</div>

<!-- three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>

<script>
/* =========================
   3D Drift Upgraded Single File
   - Improved car visuals (procedural)
   - Synthesized engine + skid audio
   - Track, cones, AI opponents
   - Low-quality toggle for older phones
   ========================= */

// ---------- Basic three.js scene ----------
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x05050a, 0.0009);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 3000);
camera.position.set(0, 6, -12);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ---------- Lights ----------
const hemi = new THREE.HemisphereLight(0xbfeaff, 0x080820, 0.9);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.95);
dir.position.set(-12, 24, 14);
dir.castShadow = true;
dir.shadow.mapSize.set(1024,1024);
dir.shadow.camera.left=-60; dir.shadow.camera.right=60; dir.shadow.camera.top=60; dir.shadow.camera.bottom=-60;
scene.add(dir);

// small backlight
const back = new THREE.DirectionalLight(0x88c0ff, 0.2);
back.position.set(10,10,-10);
scene.add(back);

// ---------- Ground / track ----------
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(1600,1600,10,10),
  new THREE.MeshStandardMaterial({color:0x121417, roughness:0.86, metalness:0.02})
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// procedural track: a wide rounded rectangle path drawn as thin slightly lighter plane
const track = new THREE.Mesh(
  new THREE.PlaneGeometry(800, 200, 1,1),
  new THREE.MeshStandardMaterial({color:0x24292e, roughness:0.7})
);
track.rotation.x = -Math.PI/2;
track.receiveShadow = true;
track.position.y = 0.01;
scene.add(track);

// lane markings (repeat texture simulated by thin boxes)
for(let i=-6;i<=6;i+=3){
  const stripe = new THREE.Mesh(new THREE.BoxGeometry(200,0.02,0.18), new THREE.MeshStandardMaterial({color:0xdedede, emissive:0x111111}));
  stripe.position.set(i*6, 0.02, 0);
  stripe.rotation.x = -Math.PI/2;
  scene.add(stripe);
}

// ---------- Environment assets (boxes) ----------
const boxGeom = new THREE.BoxGeometry(1,1,1);
for(let i=0;i<120;i++){
  const h = 1 + Math.random()*18;
  const m = new THREE.Mesh(boxGeom, new THREE.MeshStandardMaterial({color:0x0f1113, roughness:0.95}));
  m.scale.setScalar(1 + Math.random()*10);
  m.position.set((Math.random()-0.5)*800, m.scale.y*0.5, (Math.random()-0.5)*800);
  scene.add(m);
}

// ---------- Track cones ----------
const cones = [];
function makeCone(x,z){
  const cone = new THREE.Mesh(new THREE.ConeGeometry(0.25,0.6,12), new THREE.MeshStandardMaterial({color:0xff6a00}));
  cone.position.set(x,0.3,z);
  cone.castShadow = true;
  scene.add(cone);
  cones.push(cone);
}
// scatter cones as obstacles
for(let i=0;i<18;i++){
  const x = (Math.random()-0.5)*160;
  const z = (Math.random()-0.5)*160;
  makeCone(x,z);
}

// ---------- Better car (procedural multi-part) ----------
const car = new THREE.Group();
car.position.set(0,0.6,0);
scene.add(car);

// body
const bodyMat = new THREE.MeshStandardMaterial({color:0xff3b3b, roughness:0.25, metalness:0.4});
const bodyMesh = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.5,4.0), bodyMat);
bodyMesh.castShadow = true; bodyMesh.receiveShadow = false; bodyMesh.position.y = 0.45;
car.add(bodyMesh);

// cabin
const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.4,0.35,1.6), new THREE.MeshStandardMaterial({color:0x0e1115, roughness:0.2}));
cabin.position.set(0,0.8,-0.2); cabin.castShadow = true; car.add(cabin);

// spoiler
const spoiler = new THREE.Mesh(new THREE.BoxGeometry(1.4,0.08,0.22), bodyMat);
spoiler.position.set(0,0.72,-1.8); car.add(spoiler);

// wheels
const wheelGeom = new THREE.CylinderGeometry(0.33,0.33,0.3,18);
wheelGeom.rotateZ(Math.PI/2);
const wheelMat = new THREE.MeshStandardMaterial({color:0x050505, metalness:0.6});
const wfl = new THREE.Mesh(wheelGeom, wheelMat); wfl.position.set(-0.95,0.22,1.0); wfl.castShadow=true; car.add(wfl);
const wfr = new THREE.Mesh(wheelGeom, wheelMat); wfr.position.set(0.95,0.22,1.0); wfr.castShadow=true; car.add(wfr);
const wrl = new THREE.Mesh(wheelGeom, wheelMat); wrl.position.set(-0.95,0.22,-1.4); wrl.castShadow=true; car.add(wrl);
const wrr = new THREE.Mesh(wheelGeom, wheelMat); wrr.position.set(0.95,0.22,-1.4); wrr.castShadow=true; car.add(wrr);

// glass highlight
const glass = new THREE.Mesh(new THREE.BoxGeometry(1.38,0.28,1.48), new THREE.MeshStandardMaterial({color:0x6aa3ff, roughness:0.1, metalness:0.0, transparent:true, opacity:0.95}));
glass.position.set(0,0.78,-0.2); car.add(glass);

// add small "underbody" glow emissive
bodyMat.emissive = new THREE.Color(0x000000);

// ---------- AI opponents (simple box cars that follow waypoints) ----------
const aiCars = [];
const aiCount = 3;
const aiWaypoints = [];
// create circular waypoints
for(let i=0;i<28;i++){
  const a = (i/28)*Math.PI*2;
  aiWaypoints.push(new THREE.Vector3(Math.cos(a)*60, 0, Math.sin(a)*60));
}
function makeAICar(color){
  const g = new THREE.Group();
  const m = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.5,3.2), new THREE.MeshStandardMaterial({color:color, roughness:0.4, metalness:0.2}));
  m.castShadow=true; g.add(m);
  scene.add(g);
  return {group:g, idx: Math.floor(Math.random()*aiWaypoints.length), speed: 8 + Math.random()*6};
}
for(let i=0;i<aiCount;i++) aiCars.push(makeAICar( i===0?0x00aaff: (i===1?0x55ff66:0xffdd55) ));

// ---------- Particles (smoke) ----------
let particleCount = 140;
const particlesGeo = new THREE.BufferGeometry();
let positions = new Float32Array(particleCount*3);
for(let i=0;i<particleCount;i++){ positions[i*3]=0; positions[i*3+1]=-10; positions[i*3+2]=0; }
particlesGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
const tiny = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMAgMAAADbK1i/AAAADFBMVEUAAAD////MzMyZmZm6UOJlAAAAAnRSTlMAAHaTzTgAAAAQSURBVAjXY2AAAAABAQEAa2cGsgAAAABJRU5ErkJggg==');
const particlesMat = new THREE.PointsMaterial({size:0.5, map:tiny, transparent:true, opacity:0.6, depthWrite:false, color:0xdddddd});
const particles = new THREE.Points(particlesGeo, particlesMat);
particles.frustumCulled=false;
scene.add(particles);

// ---------- Controls & input ----------
const keys = {left:false, right:false, up:false, down:false, space:false};
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft') keys.left=true;
  if(e.key==='ArrowRight') keys.right=true;
  if(e.key==='ArrowUp') keys.up=true;
  if(e.key==='ArrowDown') keys.down=true;
  if(e.key===' ') keys.space=true;
});
window.addEventListener('keyup', e=>{
  if(e.key==='ArrowLeft') keys.left=false;
  if(e.key==='ArrowRight') keys.right=false;
  if(e.key==='ArrowUp') keys.up=false;
  if(e.key==='ArrowDown') keys.down=false;
  if(e.key===' ') keys.space=false;
});
// mobile pads
const leftPad = document.getElementById('leftPad');
const rightPad = document.getElementById('rightPad');
const upPad = document.getElementById('upPad');
function addTouch(el, downCb, upCb){
  el.addEventListener('touchstart', e=>{e.preventDefault(); downCb();},{passive:false});
  el.addEventListener('touchend', e=>{e.preventDefault(); upCb();},{passive:false});
}
addTouch(leftPad, ()=> keys.left=true, ()=> keys.left=false);
addTouch(rightPad, ()=> keys.right=true, ()=> keys.right=false);
addTouch(upPad, ()=> keys.up=true, ()=> keys.up=false);

// ---------- Physics-ish state ----------
let vel = new THREE.Vector3();
let yaw = 0;
let throttle = 0;
let steerInput = 0;
let handbrake = false;
let params = {
  maxSpeed:50, accel:35, steerSpeed:3.2, driftFactor:0.86, grip:0.92, downforce:8, smokeThreshold:3.5, score:0
};

// ---------- Audio (synth engine + skid) ----------
let audioEnabled = true;
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let ctxAudio = audioEnabled ? new AudioCtx() : null;
let engineOsc, engineGain, skidGain, skidNoise;
function initAudio(){
  if(!audioEnabled) return;
  if(ctxAudio.state === 'suspended') ctxAudio.resume();
  engineOsc = ctxAudio.createOscillator();
  engineGain = ctxAudio.createGain();
  engineOsc.type = 'sawtooth';
  engineOsc.frequency.value = 80; // base
  engineGain.gain.value = 0.0005;
  engineOsc.connect(engineGain);
  engineGain.connect(ctxAudio.destination);
  engineOsc.start();

  // skid noise (simple filtered buffer-source using oscillator+bandpass isn't great; use noise via script)
  // create a noise buffer
  const bufferSize = 2*ctxAudio.sampleRate;
  const noiseBuffer = ctxAudio.createBuffer(1, bufferSize, ctxAudio.sampleRate);
  const output = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) output[i] = (Math.random()*2-1)*0.5;
  skidNoise = ctxAudio.createBufferSource();
  skidNoise.buffer = noiseBuffer;
  skidNoise.loop = true;
  const skidFilter = ctxAudio.createBiquadFilter();
  skidFilter.type = 'bandpass';
  skidFilter.frequency.value = 1000;
  skidGain = ctxAudio.createGain();
  skidGain.gain.value = 0.0;
  skidNoise.connect(skidFilter);
  skidFilter.connect(skidGain);
  skidGain.connect(ctxAudio.destination);
  skidNoise.start();
}
if(audioEnabled) initAudio();

// ---------- UI refs ----------
const speedEl = document.getElementById('speed');
const driftEl = document.getElementById('drift');
const scoreEl = document.getElementById('score');
const qualityBtn = document.getElementById('qualityBtn');
const soundBtn = document.getElementById('soundBtn');
const restartBtn = document.getElementById('restartBtn');

let highQuality = true;
qualityBtn.onclick = ()=>{
  highQuality = !highQuality;
  qualityBtn.innerText = 'Quality: ' + (highQuality ? 'High' : 'Low');
  // adjust particle count and shadow settings
  particleCount = highQuality ? 140 : 40;
  // recreate particle buffer
  const newPos = new Float32Array(particleCount*3);
  for (let i=0;i<particleCount;i++){ newPos[i*3+1] = -10; }
  particles.geometry.setAttribute('position', new THREE.BufferAttribute(newPos,3));
  renderer.shadowMap.enabled = highQuality;
  dir.shadow.mapSize.set(highQuality?1024:256, highQuality?1024:256);
};
soundBtn.onclick = ()=>{
  audioEnabled = !audioEnabled;
  soundBtn.innerText = 'Sound: ' + (audioEnabled ? 'On' : 'Off');
  if(audioEnabled && !ctxAudio){ ctxAudio = new AudioCtx(); initAudio(); }
  if(!audioEnabled && ctxAudio){ try{ ctxAudio.suspend(); }catch(e){} }
};
restartBtn.onclick = resetPosition;

// ---------- Helper: local velocity ----------
function getLocalVel(){
  const inv = new THREE.Matrix4().extractRotation(car.matrixWorld).invert();
  return vel.clone().applyMatrix4(inv);
}

// ---------- Particles update ----------
function updateParticles(spawning, dt){
  const posAttr = particles.geometry.attributes.position;
  const arr = posAttr.array;
  for (let i=0;i<particleCount;i++){
    const idx = i*3;
    // if below ground, re-init off-screen
    if (arr[idx+1] < -5) {
      arr[idx] = car.position.x + (Math.random()-0.5)*0.8;
      arr[idx+1] = car.position.y - 0.1;
      arr[idx+2] = car.position.z - 1.4 + (Math.random()*0.6);
    } else {
      arr[idx] += (Math.random()-0.5) * 0.02;
      arr[idx+1] += 0.02 + Math.random()*0.04;
      arr[idx+2] += (Math.random()-0.5) * 0.02;
      if (!spawning) arr[idx+1] -= 0.02;
    }
  }
  posAttr.needsUpdate = true;
}

// ---------- Simple collision (car vs cones) ----------
function checkConeCollisions(){
  for (let c of cones){
    const d = car.position.distanceTo(c.position);
    if (d < 1.2){
      // small bounce / slow down
      vel.multiplyScalar(0.5);
      params.score = Math.max(0, params.score - 8);
      // move cone a bit
      c.position.x += (Math.random()-0.5)*2.2;
      c.position.z += (Math.random()-0.5)*2.2;
      if (audioEnabled && skidGain) skidGain.gain.value = 0.08;
      setTimeout(()=>{ if(skidGain) skidGain.gain.value = 0.0; }, 120);
    }
  }
}

// ---------- Simple collision (car vs AI) ----------
function checkAICollisions(){
  for (let ai of aiCars){
    const d = car.position.distanceTo(ai.group.position);
    if (d < 2.1){
      // both cars bounce a little
      const push = car.position.clone().sub(ai.group.position).setY(0).normalize().multiplyScalar(3);
      vel.add(push);
      ai.speed *= 0.85;
      params.score = Math.max(0, params.score - 6);
      if (audioEnabled && skidGain) skidGain.gain.value = 0.06;
      setTimeout(()=>{ if(skidGain) skidGain.gain.value = 0.0; }, 120);
    }
  }
}

// ---------- Reset position ----------
function resetPosition(){
  car.position.set(0,0.6,0);
  vel.set(0,0,0);
  yaw = 0;
  params.score = 0;
}

// ---------- AI update ----------
function updateAI(dt){
  const activeAI = highQuality ? aiCars.length : Math.min(1, aiCars.length);
  for (let i=0;i<activeAI;i++){
    const ai = aiCars[i];
    const target = aiWaypoints[ai.idx];
    // if close to target, advance
    const dir = target.clone().sub(ai.group.position);
    if (dir.length() < 4) ai.idx = (ai.idx+1) % aiWaypoints.length;
    const desired = dir.clone().normalize().multiplyScalar(ai.speed*dt);
    ai.group.position.add(desired);
    // orient toward next waypoint smoothly
    const look = aiWaypoints[ai.idx].clone().sub(ai.group.position).normalize();
    const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), look);
    ai.group.quaternion.slerp(q, 0.06);
    // simple wobble lane movement
    ai.group.position.y = 0.3;
  }
}

// ---------- Main update loop ----------
let last = performance.now();
function animate(t){
  const dt = Math.min(0.033, (t-last)/1000);
  last = t;

  // inputs
  throttle = keys.up ? 1 : (keys.down ? -0.35 : 0);
  steerInput = (keys.left? -1:0) + (keys.right? 1:0);
  handbrake = keys.space;

  // forward direction and acceleration
  const forward = new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion);
  const accelVec = forward.clone().multiplyScalar(throttle * params.accel * dt);
  vel.add(accelVec);

  // custom drag
  vel.multiplyScalar(0.994);

  // steering - yaw rate depends on speed
  const speed = vel.length();
  const speedFactor = clamp(speed/10, 0.05, 1.0);
  const yawRate = steerInput * params.steerSpeed * (1 + (0.6 - speedFactor));
  yaw += yawRate * dt * (speed / (1+speed));

  // compute local velocity and lateral
  const inv = new THREE.Matrix4().extractRotation(car.matrixWorld).invert();
  const local = vel.clone().applyMatrix4(inv);
  const lateral = local.x, longitudinal = local.z;
  const slipAngle = Math.atan2(Math.abs(lateral), Math.max(0.0001, Math.abs(longitudinal))) * (180/Math.PI);
  const isDrifting = Math.abs(lateral) > params.smokeThreshold && Math.abs(slipAngle) > 7;

  // lateral damping / drift
  const lateralDamping = handbrake ? 0.62 : (isDrifting ? params.driftFactor : params.grip);
  local.x *= lateralDamping;
  // reconstruct world velocity
  const worldVel = local.applyMatrix4(new THREE.Matrix4().makeRotationFromQuaternion(car.quaternion));
  vel.copy(worldVel);

  // subtle downforce
  vel.add(forward.clone().multiplyScalar(-params.downforce * 0.0005 * speed * dt));

  // clamp speed
  if (vel.length() > params.maxSpeed) vel.setLength(params.maxSpeed);

  // move car
  car.position.addScaledVector(vel, dt);

  // orientation: blend yaw and velocity
  if (vel.length() > 0.5){
    const targetQ = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), vel.clone().normalize());
    car.quaternion.slerp(targetQ, 0.02 + (isDrifting?0.12:0.05));
  } else {
    car.quaternion.slerp(new THREE.Quaternion().setFromEuler(new THREE.Euler(0,yaw,0)), 0.08);
  }

  // wheel spin visual
  const wheelSpin = vel.length()*6;
  [wfl,wfr,wrl,wrr].forEach(w=> w.rotation.x += wheelSpin*dt);

  // update particles
  updateParticles(isDrifting && throttle>0.6, dt);

  // sound: engine pitch & skid
  if (audioEnabled && engineOsc){
    const rpm = 400 + vel.length()*60;
    engineOsc.frequency.linearRampToValueAtTime(80 + vel.length()*10, ctxAudio.currentTime + 0.02);
    engineGain.gain.linearRampToValueAtTime(0.0008 + (vel.length()/params.maxSpeed)*0.003, ctxAudio.currentTime + 0.02);
    if (isDrifting && Math.abs(lateral)>params.smokeThreshold){
      skidGain.gain.linearRampToValueAtTime(0.04 + Math.min(0.14, Math.abs(lateral)*0.01), ctxAudio.currentTime + 0.02);
    } else {
      skidGain.gain.linearRampToValueAtTime(0.0, ctxAudio.currentTime + 0.02);
    }
  }

  // camera follow
  const camPos = car.position.clone().add(new THREE.Vector3(0, 2.8, -8).applyQuaternion(car.quaternion));
  camera.position.lerp(camPos, 0.12);
  camera.lookAt(car.position.clone().add(new THREE.Vector3(0,1.2,0)));
  camera.fov = 55 + clamp(vel.length()/params.maxSpeed * 10, 0, 12);
  camera.updateProjectionMatrix();

  // check collisions
  checkConeCollisions();
  checkAICollisions();

  // update AI
  updateAI(dt);

  // update UI & score
  speedEl.innerText = 'Speed: ' + Math.round(vel.length()*3.6) + ' km/h';
  driftEl.innerText = 'Drift: ' + Math.round(Math.abs(local.x)*10);
  if (isDrifting) params.score += Math.abs(local.x) * dt * 6;
  scoreEl.innerText = 'Score: ' + Math.floor(params.score);

  // render
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

// ---------- Utilities ----------
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// start animation
requestAnimationFrame(animate);

// ---------- initial particle attribute set -----------
for (let i=0;i<particleCount;i++){ positions[i*3+1] = -10; }
particles.geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));

// ---------- initialize audio automatically on first touch/click (mobile autoplay policy) ----------
function unlockAudio(){
  if(!ctxAudio) return;
  if(ctxAudio.state === 'suspended') ctxAudio.resume();
  // small click to allow audio
  if(!engineOsc){ initAudio(); }
  window.removeEventListener('touchstart', unlockAudio);
}
window.addEventListener('touchstart', unlockAudio, {passive:true});
window.addEventListener('mousedown', unlockAudio);

// ---------- Done ----------
console.log('3D Drift Upgraded — ready');
</script>
</body>
</html>
